//go:build ignore

// generate_parser.go - Parser und Code-Generator fuer MLX-Wrapper
//
// Enthaelt:
// - parseFunctions: Parst C-Funktionsdeklarationen
// - generateWrapperFiles: Generiert Header und Implementation
package main

import (
	"bytes"
	"fmt"
	"os"
	"regexp"
	"strings"
)

// parseFunctions parst Funktionsdeklarationen aus bereinigtem Content
func parseFunctions(content string) []Function {
	var functions []Function

	// Match function declarations: return_type function_name(params);
	// Matches both mlx_* and _mlx_* functions
	pattern := regexp.MustCompile(`\b((?:const\s+)?(?:struct\s+)?[\w\s]+?[\*\s]*)\s+(_?mlx_\w+)\s*\(([^)]*(?:\([^)]*\)[^)]*)*)\)\s*;`)

	matches := pattern.FindAllStringSubmatch(content, -1)
	for _, match := range matches {
		returnType := strings.TrimSpace(match[1])
		funcName := strings.TrimSpace(match[2])
		params := strings.TrimSpace(match[3])

		// Skip if this looks like a variable declaration
		if params == "" || strings.Contains(params, "{") {
			continue
		}

		// Clean up return type
		returnType = strings.Join(strings.Fields(returnType), " ")

		// Extract parameter names
		paramNames := extractParamNames(params)

		// Check if ARM64 guard is needed
		needsGuard := needsARM64Guard(funcName, returnType, params)

		functions = append(functions, Function{
			Name:            funcName,
			ReturnType:      returnType,
			Params:          params,
			ParamNames:      paramNames,
			NeedsARM64Guard: needsGuard,
		})
	}

	return functions
}

// generateWrapperFiles generiert Header- und Implementation-Dateien
func generateWrapperFiles(functions []Function, headerPath, implPath string) error {
	// Generate header file
	headerContent := generateHeaderFile(functions)
	if err := os.WriteFile(headerPath, headerContent, 0644); err != nil {
		return fmt.Errorf("failed to write header file: %w", err)
	}

	// Generate implementation file
	implContent := generateImplFile(functions)
	if err := os.WriteFile(implPath, implContent, 0644); err != nil {
		return fmt.Errorf("failed to write implementation file: %w", err)
	}

	return nil
}

// generateHeaderFile erstellt den Header-Datei-Inhalt
func generateHeaderFile(functions []Function) []byte {
	var headerBuf bytes.Buffer

	headerBuf.WriteString("// AUTO-GENERATED by generate_wrappers.go - DO NOT EDIT\n")
	headerBuf.WriteString("// This file provides wrapper declarations for MLX-C functions that use dlopen/dlsym\n")
	headerBuf.WriteString("//\n")
	headerBuf.WriteString("// Strategy: Include MLX-C headers for type definitions, then provide wrapper\n")
	headerBuf.WriteString("// functions that shadow the originals, allowing Go code to call them directly (e.g., C.mlx_add).\n")
	headerBuf.WriteString("// Function pointers are defined in mlx.c (single compilation unit).\n\n")
	headerBuf.WriteString("#ifndef MLX_WRAPPERS_H\n")
	headerBuf.WriteString("#define MLX_WRAPPERS_H\n\n")

	headerBuf.WriteString("// Include MLX headers for type definitions and original declarations\n")
	headerBuf.WriteString("#include \"mlx/c/mlx.h\"\n")
	headerBuf.WriteString("#include \"mlx_dynamic.h\"\n")
	headerBuf.WriteString("#include <stdio.h>\n\n")

	// Undef all MLX functions to avoid conflicts
	headerBuf.WriteString("// Undefine any existing MLX function macros\n")
	for _, fn := range functions {
		headerBuf.WriteString(fmt.Sprintf("#undef %s\n", fn.Name))
	}
	headerBuf.WriteString("\n")

	// Function pointer extern declarations
	headerBuf.WriteString("// Function pointer declarations (defined in mlx.c, loaded via dlsym)\n")
	for _, fn := range functions {
		if fn.NeedsARM64Guard {
			headerBuf.WriteString("#if defined(__aarch64__) || defined(_M_ARM64)\n")
		}
		headerBuf.WriteString(fmt.Sprintf("extern %s (*%s_ptr)(%s);\n", fn.ReturnType, fn.Name, fn.Params))
		if fn.NeedsARM64Guard {
			headerBuf.WriteString("#endif\n")
		}
	}
	headerBuf.WriteString("\n")

	// Initialization function declaration
	headerBuf.WriteString("// Initialize all function pointers via dlsym (defined in mlx.c)\n")
	headerBuf.WriteString("int mlx_load_functions(void* handle);\n\n")

	// Wrapper function declarations
	headerBuf.WriteString("// Wrapper function declarations that call through function pointers\n")
	headerBuf.WriteString("// Go code calls these directly as C.mlx_* (no #define redirection needed)\n")
	for _, fn := range functions {
		if fn.NeedsARM64Guard {
			headerBuf.WriteString("#if defined(__aarch64__) || defined(_M_ARM64)\n")
		}
		headerBuf.WriteString(fmt.Sprintf("%s %s(%s);\n", fn.ReturnType, fn.Name, fn.Params))
		if fn.NeedsARM64Guard {
			headerBuf.WriteString("#endif\n")
		}
		headerBuf.WriteString("\n")
	}

	headerBuf.WriteString("#endif // MLX_WRAPPERS_H\n")

	return headerBuf.Bytes()
}

// generateImplFile erstellt den Implementation-Datei-Inhalt
func generateImplFile(functions []Function) []byte {
	var implBuf bytes.Buffer

	implBuf.WriteString("// AUTO-GENERATED by generate_wrappers.go - DO NOT EDIT\n")
	implBuf.WriteString("// This file contains the function pointer definitions and initialization\n")
	implBuf.WriteString("// All function pointers are in a single compilation unit to avoid duplication\n\n")

	implBuf.WriteString("#include \"mlx/c/mlx.h\"\n")
	implBuf.WriteString("#include \"mlx_dynamic.h\"\n")
	implBuf.WriteString("#include <stdio.h>\n")
	implBuf.WriteString("#include <dlfcn.h>\n\n")

	// Function pointer definitions
	implBuf.WriteString("// Function pointer definitions\n")
	for _, fn := range functions {
		if fn.NeedsARM64Guard {
			implBuf.WriteString("#if defined(__aarch64__) || defined(_M_ARM64)\n")
		}
		implBuf.WriteString(fmt.Sprintf("%s (*%s_ptr)(%s) = NULL;\n", fn.ReturnType, fn.Name, fn.Params))
		if fn.NeedsARM64Guard {
			implBuf.WriteString("#endif\n")
		}
	}
	implBuf.WriteString("\n")

	// Initialization function
	implBuf.WriteString("// Initialize all function pointers via dlsym\n")
	implBuf.WriteString("int mlx_load_functions(void* handle) {\n")
	implBuf.WriteString("    if (handle == NULL) {\n")
	implBuf.WriteString("        fprintf(stderr, \"MLX: Invalid library handle\\n\");\n")
	implBuf.WriteString("        return -1;\n")
	implBuf.WriteString("    }\n\n")

	for _, fn := range functions {
		if fn.NeedsARM64Guard {
			implBuf.WriteString("#if defined(__aarch64__) || defined(_M_ARM64)\n")
		}
		implBuf.WriteString(fmt.Sprintf("    %s_ptr = dlsym(handle, \"%s\");\n", fn.Name, fn.Name))
		implBuf.WriteString(fmt.Sprintf("    if (%s_ptr == NULL) {\n", fn.Name))
		implBuf.WriteString(fmt.Sprintf("        fprintf(stderr, \"MLX: Failed to load symbol: %s\\n\");\n", fn.Name))
		implBuf.WriteString("        return -1;\n")
		implBuf.WriteString("    }\n")
		if fn.NeedsARM64Guard {
			implBuf.WriteString("#endif\n")
		}
	}

	implBuf.WriteString("    return 0;\n")
	implBuf.WriteString("}\n\n")

	// Wrapper function implementations
	implBuf.WriteString("// Wrapper function implementations that call through function pointers\n")
	for _, fn := range functions {
		if fn.NeedsARM64Guard {
			implBuf.WriteString("#if defined(__aarch64__) || defined(_M_ARM64)\n")
		}
		implBuf.WriteString(fmt.Sprintf("%s %s(%s) {\n", fn.ReturnType, fn.Name, fn.Params))

		// Call through function pointer
		if fn.ReturnType != "void" {
			implBuf.WriteString(fmt.Sprintf("    return %s_ptr(", fn.Name))
		} else {
			implBuf.WriteString(fmt.Sprintf("    %s_ptr(", fn.Name))
		}

		// Pass parameters
		implBuf.WriteString(strings.Join(fn.ParamNames, ", "))
		implBuf.WriteString(");\n")
		implBuf.WriteString("}\n")
		if fn.NeedsARM64Guard {
			implBuf.WriteString("#endif\n")
		}
		implBuf.WriteString("\n")
	}

	return implBuf.Bytes()
}
